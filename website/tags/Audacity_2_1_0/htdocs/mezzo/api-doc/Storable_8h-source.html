<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Mezzo: Storable.h Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.6 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a></div>
<h1>Storable.h</h1><a href="Storable_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/**********************************************************************</span>
00002 <span class="comment"></span>
00003 <span class="comment">  Mezzo: A Cross-Platform Audio Editing Engine</span>
00004 <span class="comment"></span>
00005 <span class="comment">  Storable.h</span>
00006 <span class="comment"></span>
00007 <span class="comment">  Copyright (c) 2004 Joshua Haberman</span>
00008 <span class="comment"></span>
00009 <span class="comment">  This program is free software and comes with no warranty; for more</span>
00010 <span class="comment">  information, see the file LICENSE.txt or visit</span>
00011 <span class="comment">  http://audacity.sourceforge.net/mezzo/license/</span>
00012 <span class="comment"></span>
00013 <span class="comment">**********************************************************************/</span>
00014 
00015 <span class="preprocessor">#ifndef __MEZZO_STORABLE__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#define __MEZZO_STORABLE__</span>
00017 <span class="preprocessor"></span>
00018 <span class="preprocessor">#include &lt;map&gt;</span>
00019 <span class="preprocessor">#include &lt;string&gt;</span>
00020 <span class="preprocessor">#include &lt;set&gt;</span>
00021 
00022 <span class="keyword">namespace </span>Mezzo {
00023 
<a name="l00024"></a><a class="code" href="namespaceMezzo.html#a2">00024</a> <span class="keyword">typedef</span> std::map&lt;std::string,std::string&gt; <a class="code" href="namespaceMezzo.html#a2">AttrDict</a>;
00025 
00026 <span class="keyword">class </span><a class="code" href="classMezzo_1_1ManagedFile.html">ManagedFile</a>;
00027 <span class="keyword">class </span><a class="code" href="classMezzo_1_1Storable.html">Storable</a>;
00028 <span class="comment"></span>
00029 <span class="comment">/// An object that can store hierarchical data in a persistent medium (eg. a disk file)</span>
00030 <span class="comment"></span><span class="comment"></span>
00031 <span class="comment">/// An abstract interface for an object that can store hierarchical data in</span>
00032 <span class="comment">/// a persistent medium (eg. to a disk file).  The most common implementation</span>
00033 <span class="comment">/// is to store to an XML file, as in XMLStorer.</span>
00034 <span class="comment">///</span>
00035 <span class="comment">/// Since the structures being stored are not strictly hierarchical, there</span>
00036 <span class="comment">/// is a facility for creating identifiers for objects that makes it possible</span>
00037 <span class="comment">/// to create references between objects from different hierarchies.  When</span>
00038 <span class="comment">/// an object that may be referenced saves itself, it will create an ID</span>
00039 <span class="comment">/// that is associated with its memory address.  Later, when a different object</span>
00040 <span class="comment">/// wants to refer to the first object, it asks the storer if there is an</span>
00041 <span class="comment">/// ID associated with that address, and if so it can just store the ID.</span>
00042 <span class="comment"></span>
<a name="l00043"></a><a class="code" href="classMezzo_1_1Storer.html">00043</a> <span class="keyword">class </span><a class="code" href="classMezzo_1_1Storer.html">Storer</a>
00044 {
00045  <span class="keyword">public</span>:
<a name="l00046"></a><a class="code" href="classMezzo_1_1Storer.html#a0">00046</a>    <span class="keyword">virtual</span> <a class="code" href="classMezzo_1_1Storer.html#a0">~Storer</a>() { }
00047 <span class="comment"></span>
00048 <span class="comment">   /// Store the beginning of a hierarchical node.</span>
00049 <span class="comment"></span>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzo_1_1Storer.html#a1">StoreBeginNode</a>(std::string name, <a class="code" href="namespaceMezzo.html#a2">AttrDict</a> attr) = 0;
00050 <span class="comment"></span>
00051 <span class="comment">   /// Store the end of a hierarchical node.</span>
00052 <span class="comment"></span>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzo_1_1Storer.html#a2">StoreEndNode</a>(std::string name) = 0;
00053 <span class="comment"></span>
00054 <span class="comment">   /// Store a node that doesn't have any children.</span>
00055 <span class="comment"></span>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzo_1_1Storer.html#a3">StoreLeafNode</a>(std::string name, <a class="code" href="namespaceMezzo.html#a2">AttrDict</a> attr) = 0;
00056 <span class="comment"></span>
00057 <span class="comment">   /// Create an ID that is associated with this object</span>
00058 <span class="comment"></span>   std::string <a class="code" href="classMezzo_1_1Storer.html#a4">CreateID</a>(<a class="code" href="classMezzo_1_1Storable.html">Storable</a> *obj);
00059 <span class="comment"></span>
00060 <span class="comment">   /// Retrieve an ID associated with this object</span>
00061 <span class="comment"></span>   std::string <a class="code" href="classMezzo_1_1Storer.html#a5">GetID</a>(<a class="code" href="classMezzo_1_1Storable.html">Storable</a> *obj);
00062 
00063  <span class="keyword">protected</span>:
<a name="l00064"></a><a class="code" href="classMezzo_1_1Storer.html#b0">00064</a>    <a class="code" href="classMezzo_1_1Storer.html#b0">Storer</a>():mLastID(0) { }
00065 
00066  <span class="keyword">private</span>:
00067    std::map&lt;Storable*,std::string&gt; mIdObjects;
00068    <span class="keywordtype">int</span> mLastID;
00069 };
00070 <span class="comment"></span>
00071 <span class="comment">/// An object that can load hierarchical data from a persistent medium (eg. a disk file)</span>
00072 <span class="comment"></span><span class="comment"></span>
00073 <span class="comment">/// An abstract interface for an object that can load hierarchical data from</span>
00074 <span class="comment">/// a persistent medium (eg. to a disk file).  The most common implementation</span>
00075 <span class="comment">/// is to load from an XML file, as in XMLLoader.  This class loads data</span>
00076 <span class="comment">/// stored by a corresponding Storer class.</span>
00077 <span class="comment">///</span>
00078 <span class="comment">/// Since the structures being loaded are not strictly hierarchical, there</span>
00079 <span class="comment">/// is a facility for creating identifiers for objects that makes it possible</span>
00080 <span class="comment">/// to create references between objects from different hierarchies.  When</span>
00081 <span class="comment">/// an object that that is being loaded sees that an ID has been stored for that</span>
00082 <span class="comment">/// object, it will register itself with the loader so that other objects can</span>
00083 <span class="comment">/// obtain a pointer to this object.</span>
00084 <span class="comment"></span>
<a name="l00085"></a><a class="code" href="classMezzo_1_1Loader.html">00085</a> <span class="keyword">class </span><a class="code" href="classMezzo_1_1Loader.html">Loader</a>
00086 {
00087  <span class="keyword">public</span>:
<a name="l00088"></a><a class="code" href="classMezzo_1_1Loader.html#a0">00088</a>    <span class="keyword">virtual</span> <a class="code" href="classMezzo_1_1Loader.html#a0">~Loader</a>() { }
00089 
<a name="l00090"></a><a class="code" href="structMezzo_1_1Loader_1_1Token.html">00090</a>    <span class="keyword">struct </span><a class="code" href="structMezzo_1_1Loader_1_1Token.html">Token</a> {
00091       <span class="keyword">enum</span> {
00092          <a class="code" href="structMezzo_1_1Loader_1_1Token.html#w2w0">beginNode</a>,
00093          <a class="code" href="structMezzo_1_1Loader_1_1Token.html#w2w1">endNode</a>
00094       } type;
<a name="l00095"></a><a class="code" href="structMezzo_1_1Loader_1_1Token.html#o1">00095</a>       std::string <a class="code" href="structMezzo_1_1Loader_1_1Token.html#o1">name</a>;
<a name="l00096"></a><a class="code" href="structMezzo_1_1Loader_1_1Token.html#o2">00096</a>       <a class="code" href="namespaceMezzo.html#a2">AttrDict</a> <a class="code" href="structMezzo_1_1Loader_1_1Token.html#o2">attrs</a>;
00097    };
00098 
00099    <span class="keyword">virtual</span> <a class="code" href="structMezzo_1_1Loader_1_1Token.html">Token</a> <a class="code" href="classMezzo_1_1Loader.html#a1">GetNextToken</a>() = 0;
00100    <span class="keyword">virtual</span> <a class="code" href="structMezzo_1_1Loader_1_1Token.html">Token</a> <a class="code" href="classMezzo_1_1Loader.html#a2">PeekNextToken</a>() = 0;
00101 
00102    <span class="keywordtype">void</span> <a class="code" href="classMezzo_1_1Loader.html#a3">RegisterObj</a>(std::string <span class="keywordtype">id</span>, <a class="code" href="classMezzo_1_1Storable.html">Storable</a> *obj);
00103    <a class="code" href="classMezzo_1_1Storable.html">Storable</a> *<a class="code" href="classMezzo_1_1Loader.html#a4">GetObj</a>(std::string <span class="keywordtype">id</span>);
00104 
00105  <span class="keyword">private</span>:
00106    std::map&lt;std::string,Storable*&gt; mIdObjects;
00107 };
00108 
<a name="l00109"></a><a class="code" href="classMezzo_1_1Storable.html">00109</a> <span class="keyword">class </span><a class="code" href="classMezzo_1_1Storable.html">Storable</a>
00110 {
00111  <span class="keyword">public</span>:
<a name="l00112"></a><a class="code" href="classMezzo_1_1Storable.html#a0">00112</a>    <span class="keyword">virtual</span> <a class="code" href="classMezzo_1_1Storable.html#a0">~Storable</a>() { }
00113 
00114    <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classMezzo_1_1Storable.html#a1">Store</a>(<a class="code" href="classMezzo_1_1Storer.html">Storer</a>&amp; storer) = 0;
00115 <span class="comment"></span>
00116 <span class="comment">   /// Get the list of storables (if any) that must be stored before this object can be stored</span>
<a name="l00117"></a><a class="code" href="classMezzo_1_1Storable.html#a2">00117</a> <span class="comment"></span>   <span class="keyword">virtual</span> std::set&lt;Storable*&gt; <a class="code" href="classMezzo_1_1Storable.html#a2">GetPrereqStorables</a>() { std::set&lt;Storable*&gt; x; <span class="keywordflow">return</span> x; }
00118 <span class="comment"></span>
00119 <span class="comment">   /// Get the list of ManagedFiles (if any) that must be locked for this object to be loadable</span>
<a name="l00120"></a><a class="code" href="classMezzo_1_1Storable.html#a3">00120</a> <span class="comment"></span>   <span class="keyword">virtual</span> std::set&lt;ManagedFile*&gt; <a class="code" href="classMezzo_1_1Storable.html#a3">GetManagedFilesInUse</a>() { std::set&lt;ManagedFile*&gt; x; <span class="keywordflow">return</span> x; }
00121 
00122    <span class="keyword">static</span> <a class="code" href="classMezzo_1_1Storable.html">Storable</a>* <a class="code" href="classMezzo_1_1Storable.html#e0">Load</a>(<a class="code" href="classMezzo_1_1Loader.html">Loader</a>&amp; loader);
00123 };
00124 
00125 } <span class="comment">// namespace</span>
00126 
00127 <span class="preprocessor">#endif</span>
00128 <span class="preprocessor"></span>
00129 <span class="comment">// Indentation settings for Vim and Emacs.  Please do not modify past this point.</span>
00130 <span class="comment">//</span>
00131 <span class="comment">// Local Variables:</span>
00132 <span class="comment">// c-basic-offset: 3</span>
00133 <span class="comment">// indent-tabs-mode: nil</span>
00134 <span class="comment">// End:</span>
00135 <span class="comment">//</span>
00136 <span class="comment">// vim: et sts=3 sw=3</span>
00137 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri May 19 20:42:23 2006 for Mezzo by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.6 </small></address>
</body>
</html>
